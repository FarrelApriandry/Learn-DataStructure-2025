# -*- coding: utf-8 -*-
"""2430506056_StrukDat_Queue.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U4rzuHO0Py5lKsUxzXwMRW7rT1MMsd5w
"""

class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)
        return None

    def is_empty(self):
        return len(self.items) == 0

queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
print(queue.dequeue())  # Output: 1

class CircularQueue:
    def __init__(self, size):
        self.queue = [None] * size
        self.size = size
        self.front = self.rear = -1

    def enqueue(self, item):
        if (self.rear + 1) % self.size == self.front:
            print("Queue is full")
            return
        elif self.front == -1:
            self.front = self.rear = 0
        else:
            self.rear = (self.rear + 1) % self.size
        self.queue[self.rear] = item

    def dequeue(self):
        if self.front == -1:
            print("Queue is empty")
            return None
        item = self.queue[self.front]
        if self.front == self.rear:
            self.front = self.rear = -1
        else:
            self.front = (self.front + 1) % self.size
        return item

cq = CircularQueue(3)
cq.enqueue(1)
cq.enqueue(2)
cq.enqueue(3)
print(cq.dequeue())  # Output: 1

import queue
pq = queue.PriorityQueue()
pq.put((1, "Task 1"))
pq.put((3, "Task 3"))
pq.put((2, "Task 2"))
print(pq.get()[1])  # Output: Task 1 (Lowest priority first)
print(pq.get()[1])  # Output: Task 2
print(pq.get()[1])  # Output: Task 3

from collections import deque

queue = deque()
queue.append(1)  # Enqueue from right
queue.appendleft(2)  # Enqueue from left
print(queue.pop())  # Output: 1
print(queue.popleft())  # Output: 2

queue = []
queue.append(1)
queue.append(2)
queue.append(3)
print(queue.pop(0))  # Output: 1

from collections import deque
queue = deque()
queue.append(1)
queue.append(2)
queue.append(3)
print(queue.popleft())  # Output: 1

from queue import Queue
queue = Queue()
queue.put(1)
queue.put(2)
queue.put(3)
print(queue.get())  # Output: 1

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedListQueue:
    def __init__(self):
        self.front = self.rear = None

    def enqueue(self, item):
        new_node = Node(item)
        if self.rear is None:
            self.front = self.rear = new_node
            return
        self.rear.next = new_node
        self.rear = new_node

    def dequeue(self):
        if self.front is None:
            return None
        item = self.front.data
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        return item

ll_queue = LinkedListQueue()
ll_queue.enqueue(1)
ll_queue.enqueue(2)
print(ll_queue.dequeue())  # Output: 1
print(ll_queue.dequeue())  # Output: 2

"""# **Implementasi Queue**

## Implementasi Queue dengan List
"""

class QueueList:
  def __init__ (self):
    self.queue = []

  def enqueue(self, item):
    self.queue.append(item)

  def dequeue(self):
    if not self.is_empty():
      return self.queue.pop(0)
    return None

  def front(self):
    return self.queue[0] if not self.is_empty() else None

  def rear(self):
    return self.queue[-1] if not self.is_empty() else None

  def is_empty(self):
    return len(self.queue) == 0

  def size(self):
    return len(self.queue)

queue = QueueList()
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
print("Queue setelah enqueue:", queue.queue)
print("Dequend element:", queue.dequeue())
print("Front element:", queue.front())
print("Rear element:", queue.rear())
print("Queue size:", queue.size())

"""## Implementasi Queue dengan collections.dequeue"""

from collections import deque

class QueueDeque:
  def __init__(self):
    self.queue = deque()

  def enqueue(self, item):
    self.queue.append(item)

  def dequeue(self):
    return self.queue.popleft() if not self.is_empty() else None

  def front(self):
    return self.queue[0] if not self.is_empty() else None

  def rear(self):
    return self.queue[-1] if not self.is_empty() else None

  def is_empty(self):
    return len(self.queue) == 0

  def size(self):
    return len(self.queue)

queue = QueueDeque()
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
print("Queue setelah enqueue:", list(queue.queue))
print("Dequend element:", queue.dequeue())
print("Front element:", queue.front())
print("Rear element:", queue.rear())
print("Queue size:", queue.size())

"""## Implementasi Queue dengan queue.Queue"""

from queue import Queue

queue = Queue()

queue.put(10)
queue.put(20)
queue.put(30)

print("Queue size:", queue.qsize())
print("Dequeue element:", queue.get())
print("Queue size setelah dequeu:", queue.qsize())

"""## Implementasi Queue dengan Linked List"""

class Node:
  def __init__(self, data):
    self.data = data
    self.next = None

class QueueLinkedList:
  def __init__(self):
    self.front = self.rear = None

  def enqueueu(self, data):
    new_node = Node(data)
    if self.rear is None:
      self.front = self.rear = new_node
      return
    self.rear.next = new_node
    self.rear = new_node

  def dequeue(self):
    if self.front is None:
      return None
    dequeued_element = self.front.data
    self.front = self.front.next
    if self.front is None:
      self.rear = None
    return dequeued_element
  def is_empty(self):
    return self.front is None

  def front_element(self):
    return self.front.data if self.front else None

  def rear_element(self):
    return self.rear.data if self.rear else None

queue = QueueLinkedList()
queue.enqueueu(10)
queue.enqueueu(20)
queue.enqueueu(30)
print("Dequeued element:", queue.dequeue())
print("Front element:", queue.front_element())
print("Rear element:", queue.rear_element())

"""# **Latihan/Tugas Praktikum**

##1.  Sistem antrian pemesanan tiket bioskop
"""

from collections import deque

class CinemaQueue:
    def __init__(self, max_capacity=10):
        self.queue = deque()
        self.max_capacity = max_capacity

    def enqueue(self, customer_id):
        if "7" in customer_id:
            print(f"VIP Customer {customer_id} gets instant access!")
        elif len(self.queue) < self.max_capacity:
            self.queue.append(customer_id)
            print(f"Customer {customer_id} added to the queue.")
        else:
            print("Queue is full! Please wait until a slot is available.")

    def dequeue(self):
        if not self.is_empty():
            served_customer = self.queue.popleft()
            print(f"Customer {served_customer} is being served.")
            return served_customer
        print("No customers in the queue.")
        return None

    def front(self):
        return self.queue[0] if not self.is_empty() else None

    def rear(self):
        return self.queue[-1] if not self.is_empty() else None

    def is_empty(self):
        return len(self.queue) == 0

    def size(self):
        return len(self.queue)

# Interactive Input
cinema_queue = CinemaQueue()
while True:
    print("\nCinema Ticket Queue System")
    print("1. Add Customer (Enqueue)")
    print("2. Serve Customer (Dequeue)")
    print("3. Show Front Customer")
    print("4. Show Rear Customer")
    print("5. Show Queue Size")
    print("6. Exit")

    choice = input("Enter your choice: ")

    if choice == "1":
        customer_id = input("Enter customer ID (e.g., AB23): ")
        cinema_queue.enqueue(customer_id)
    elif choice == "2":
        cinema_queue.dequeue()
    elif choice == "3":
        print("Front customer:", cinema_queue.front())
    elif choice == "4":
        print("Rear customer:", cinema_queue.rear())
    elif choice == "5":
        print("Queue size:", cinema_queue.size())
    elif choice == "6":
        print("Exiting system...")
        break
    else:
        print("Invalid choice. Please try again.")

"""## 2. Sistem antrian layanan fotokopi di kampus"""

from collections import deque

class PhotocopyQueue:
    def __init__(self):
        self.queue = deque()

    def enqueue(self, order_id, num_pages):
        if num_pages < 10:
            print(f"Fast Track: Order {order_id} processed immediately.")
        else:
            self.queue.append((order_id, num_pages))
            print(f"Order {order_id} with {num_pages} pages added to queue.")

    def dequeue(self):
        if self.is_empty():
            print("No orders in queue.")
            return None
        order_id, num_pages = self.queue.popleft()
        if num_pages > 100:
            remaining_pages = num_pages - 100
            self.queue.append((order_id, remaining_pages))
            print(f"Order {order_id} processed 100 pages, {remaining_pages} pages remaining.")
        else:
            print(f"Order {order_id} completed.")

    def front(self):
        return self.queue[0] if not self.is_empty() else None

    def rear(self):
        return self.queue[-1] if not self.is_empty() else None

    def is_empty(self):
        return len(self.queue) == 0

    def size(self):
        return len(self.queue)

photocopy_queue = PhotocopyQueue()
while True:
    print("\nPhotocopy Service Queue System")
    print("1. Add Order (Enqueue)")
    print("2. Process Order (Dequeue)")
    print("3. Show First Order")
    print("4. Show Last Order")
    print("5. Show Queue Size")
    print("6. Exit")

    choice = input("Enter your choice: ")

    if choice == "1":
        order_id = input("Enter order ID (e.g., ABC23): ")
        num_pages = int(input("Enter number of pages: "))
        photocopy_queue.enqueue(order_id, num_pages)
    elif choice == "2":
        photocopy_queue.dequeue()
    elif choice == "3":
        print("First order:", photocopy_queue.front())
    elif choice == "4":
        print("Last order:", photocopy_queue.rear())
    elif choice == "5":
        print("Queue size:", photocopy_queue.size())
    elif choice == "6":
        print("Exiting system...")
        break
    else:
        print("Invalid choice. Please try again.")

"""## 3. Sistem antrian kendaraan masuk ke parkiran mall"""

from collections import deque

class ParkingQueue:
    def __init__(self, capacity=15):
        self.queue = deque()
        self.capacity = capacity

    def enqueue(self, vehicle_number, is_electric=False):
        """ Adds a vehicle to the queue. Electric vehicles get priority. """
        if len(self.queue) < self.capacity:
            if is_electric:
                self.queue.appendleft(vehicle_number)
                print(f"Priority Entry: Electric Vehicle {vehicle_number} has entered first.")
            else:
                self.queue.append(vehicle_number)
                print(f"Vehicle {vehicle_number} has entered the parking queue.")
        else:
            print("Parking lot is full! Please wait until a slot is available.")

    def dequeue(self):
        """ Removes the first vehicle from the queue. """
        if not self.is_empty():
            vehicle = self.queue.popleft()
            print(f"Vehicle {vehicle} has exited the parking lot.")
            return vehicle
        print("No vehicles in the parking lot.")
        return None

    def front(self):
        """ Returns the first vehicle in the queue. """
        return self.queue[0] if not self.is_empty() else None

    def rear(self):
        """ Returns the last vehicle in the queue. """
        return self.queue[-1] if not self.is_empty() else None

    def is_empty(self):
        """ Checks if the parking lot is empty. """
        return len(self.queue) == 0

    def size(self):
        """ Returns the number of vehicles in the parking lot. """
        return len(self.queue)


parking_lot = ParkingQueue()

while True:
    print("\nMall Parking System")
    print("1. Add Vehicle (Enqueue)")
    print("2. Remove Vehicle (Dequeue)")
    print("3. Show First Vehicle (Front)")
    print("4. Show Last Vehicle (Rear)")
    print("5. Check Parking Lot Size")
    print("6. Exit")

    choice = input("Enter your choice: ")

    if choice == "1":
        city_code = input("Enter license plate: ").upper()
        is_electric = input("Is this an electric vehicle? (yes/no): ").strip().lower() == "yes"

        vehicle_number = city_code
        parking_lot.enqueue(vehicle_number, is_electric)

    elif choice == "2":
        parking_lot.dequeue()

    elif choice == "3":
        front_vehicle = parking_lot.front()
        print(f"First vehicle in queue: {front_vehicle}" if front_vehicle else "No vehicles in the parking lot.")

    elif choice == "4":
        rear_vehicle = parking_lot.rear()
        print(f"Last vehicle in queue: {rear_vehicle}" if rear_vehicle else "No vehicles in the parking lot.")

    elif choice == "5":
        print(f"Current parking lot size: {parking_lot.size()}")

    elif choice == "6":
        print("Exiting system...")
        break

    else:
        print("Invalid choice. Please try again.")

"""## 4. Sistem antrian pengambilan sertifikat di kampus"""

from collections import deque

class CertificateQueue:
    def __init__(self):
        self.regular_queue = deque()
        self.achievement_queue = deque()

    def enqueue(self, student_id, is_achiever=False):
        """ Adds a student to the queue. Achievers bypass the queue. """
        if is_achiever:
            print(f"Priority Entry: Student {student_id} can collect the certificate immediately.")
        else:
            if len(self.regular_queue) >= 20:
                self.achievement_queue.append(student_id)
                print(f"Student {student_id} added to achievement queue.")
            else:
                self.regular_queue.append(student_id)
                print(f"Student {student_id} added to the regular queue.")

    def dequeue(self):
        """ Serves the first student in line. """
        if self.achievement_queue:
            student = self.achievement_queue.popleft()
            print(f"Student {student} from the achievement queue has collected the certificate.")
        elif self.regular_queue:
            student = self.regular_queue.popleft()
            print(f"Student {student} from the regular queue has collected the certificate.")
        else:
            print("No students in the queue.")

    def front(self):
        """ Returns the first student in line. """
        return self.achievement_queue[0] if self.achievement_queue else (self.regular_queue[0] if self.regular_queue else None)

    def rear(self):
        """ Returns the last student in line. """
        return self.regular_queue[-1] if self.regular_queue else (self.achievement_queue[-1] if self.achievement_queue else None)

    def is_empty(self):
        """ Checks if both queues are empty. """
        return not self.achievement_queue and not self.regular_queue

    def size(self):
        """ Returns the total number of students in the queue. """
        return len(self.achievement_queue) + len(self.regular_queue)

# Interactive System
certificate_system = CertificateQueue()

while True:
    print("\nCertificate Collection System")
    print("1. Add Student to Queue (Enqueue)")
    print("2. Serve Student (Dequeue)")
    print("3. Show First Student (Front)")
    print("4. Show Last Student (Rear)")
    print("5. Check Queue Size")
    print("6. Exit")

    choice = input("Enter your choice: ")

    if choice == "1":
        program_code = input("Enter your ID: ").upper()
        is_achiever = input("Have you competed at the national level? (yes/no): ").strip().lower() == "yes"

        student_id = program_code
        certificate_system.enqueue(student_id, is_achiever)

    elif choice == "2":
        certificate_system.dequeue()

    elif choice == "3":
        front_student = certificate_system.front()
        print(f"First student in queue: {front_student}" if front_student else "No students in queue.")

    elif choice == "4":
        rear_student = certificate_system.rear()
        print(f"Last student in queue: {rear_student}" if rear_student else "No students in queue.")

    elif choice == "5":
        print(f"Current queue size: {certificate_system.size()}")

    elif choice == "6":
        print("Exiting system...")
        break

    else:
        print("Invalid choice. Please try again.")