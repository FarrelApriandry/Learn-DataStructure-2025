# -*- coding: utf-8 -*-
"""2430506056_StrukDat_Stack.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VjIEORBZjOXj2uSH6ejCt1swxgRKmUQp
"""

class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        return self.stack.pop() if self.stack else "Stack is empty!"

# Example Usage
s = Stack()
s.push(5)
s.push(10)
print(s.pop())  # Output: 10
print(s.pop())  # Output: 5
print(s.pop())  # Output: Stack is empty!

class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)
        print(f"Pushed {item} into stack.")

    def display(self):
        print("Current Stack:", self.stack)

s = Stack()
s.push(10)
s.push(20)
s.display()

class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.stack:
            return "Stack is empty!"
        return f"Popped {self.stack.pop()}"

    def display(self):
        print("Current Stack:", self.stack)

s = Stack()
s.push(10)
s.push(20)
print(s.pop())
s.display()

class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def peek(self):
        if not self.stack:
            return "Stack is empty!"
        return f"Top element: {self.stack[-1]}"

s = Stack()
s.push(10)
s.push(20)
print(s.peek())

class Stack:
    def __init__(self):
        self.stack = []

    def is_empty(self):
        return len(self.stack) == 0

s = Stack()
print(s.is_empty())  # True
s.stack.append(10)
print(s.is_empty())  # False

class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def size(self):
        return f"Stack size: {len(self.stack)}"

s = Stack()
s.push(10)
s.push(20)
s.push(30)
print(s.size())

"""# **Excersise**

## **Exercise 1**
"""

class Calculator:
    def __init__(self, initial_value):
        self.history = []
        self.current_value = initial_value

    def operate(self, operator, number):
        if operator == '+':
            self.history.append(self.current_value)
            self.current_value += number
        elif operator == '-':
            self.history.append(self.current_value)
            self.current_value -= number
        elif operator == '*':
            self.history.append(self.current_value)
            self.current_value *= number
        elif operator == '/':
            if number == 0:
                print("Error: Division by zero is not allowed!")
                return
            self.history.append(self.current_value)
            self.current_value /= number
        else:
            print("Invalid operator!")
            return

        print(f"Operation: {operator} {number}, Current Value: {self.current_value}")

    def undo(self):
        if not self.history:
            print("No operations to undo!")
            return
        self.current_value = self.history.pop()
        print(f"Undo operation, Current Value: {self.current_value}")

initial_value = int(input("Enter initial value: "))
calc = Calculator(initial_value)

while True:
    action = input("Enter operation (+, -, *, /) or 'undo' to undo, or 'exit' to quit: ").strip()

    if action == 'exit':
        break
    elif action == 'undo':
        calc.undo()
    else:
        try:
            number = float(input("Enter a number: "))
            calc.operate(action, number)
        except ValueError:
            print("Invalid input! Please enter a valid number.")

class NavigationHistory:
    def __init__(self):
        self.history = []
        self.forward_stack = []

    def visit_feature(self, feature_name):
        self.history.append(feature_name)
        self.forward_stack.clear()
        print(f"Visited: {feature_name}")

    def go_back(self):
        if len(self.history) > 1:
            last_feature = self.history.pop()
            self.forward_stack.append(last_feature)
            print(f"Back to: {self.history[-1]}")
        else:
            print("No previous feature to go back to!")

    def go_forward(self):
        if self.forward_stack:
            next_feature = self.forward_stack.pop()
            self.history.append(next_feature)
            print(f"Forward to: {next_feature}")
        else:
            print("No forward history available!")

    def show_history(self):
        print("\nNavigation History:", " -> ".join(self.history))
        if self.forward_stack:
            print("Forward Stack:", " -> ".join(self.forward_stack))
        print()


nav = NavigationHistory()

nav.visit_feature("A56-1")
nav.visit_feature("A56-2")
nav.visit_feature("A56-3")

while True:
    nav.show_history()
    action = input("Choose action: (B)ack, (F)orward, (E)xit: ").strip().lower()

    if action == "b":
        nav.go_back()
    elif action == "f":
        nav.go_forward()
    elif action == "e":
        print("Exiting navigation history.")
        break
    else:
        print("Invalid choice! Please enter B, F, or E.")

class EmailDraftStack:
    def __init__(self):
        self.stack = []

    def save_draft(self, subject, content):
        self.stack.append((subject, content))
        print(f"Draft '{subject}' saved.")

    def view_last_draft(self):
        if self.stack:
            subject, content = self.stack[-1]
            print(f"Last Draft - Subject: {subject}\nContent: {content}")
        else:
            print("No drafts available.")

    def delete_last_draft(self):
        if self.stack:
            deleted_draft = self.stack.pop()
            print(f"Draft '{deleted_draft[0]}' deleted.")
        else:
            print("No drafts to delete.")

    def show_all_drafts(self):
        if self.stack:
            print("\nAll Drafts:")
            for idx, (subject, content) in enumerate(self.stack, start=1):
                print(f"{idx}. {subject}: {content}")
        else:
            print("No drafts saved.")

def main():
    email_stack = EmailDraftStack()
    while True:
        print("\nEmail Draft System")
        print("1. Save a new draft")
        print("2. View last draft")
        print("3. Delete last draft")
        print("4. Show all drafts")
        print("5. Exit")
        choice = input("Choose an option: ")

        if choice == "1":
            subject = input("Enter subject: ")
            content = input("Enter email content: ")
            email_stack.save_draft(subject, content)
        elif choice == "2":
            email_stack.view_last_draft()
        elif choice == "3":
            email_stack.delete_last_draft()
        elif choice == "4":
            email_stack.show_all_drafts()
        elif choice == "5":
            print("Exiting...\n")
            break
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()

class TicketQueue:
    def __init__(self):
        self.stack = []

    def buy_ticket(self, name, movie):
        self.stack.append((name, movie))
        print(f"Ticket purchased for {name} - {movie}")

    def process_ticket(self):
        if not self.stack:
            print("No tickets to process!")
        else:
            name, movie = self.stack.pop()
            print(f"Processing ticket for {name} - {movie}")

    def view_next_ticket(self):
        if not self.stack:
            print("No tickets in queue!")
        else:
            name, movie = self.stack[-1]
            print(f"Next ticket: {name} - {movie}")

    def list_tickets(self):
        if not self.stack:
            print("No tickets purchased yet!")
        else:
            print("Tickets in queue:")
            for i, (name, movie) in enumerate(reversed(self.stack), 1):
                print(f"{i}. {name} - {movie}")

queue = TicketQueue()

while True:
    print("\n1. Buy Ticket")
    print("2. Process Ticket")
    print("3. View Next Ticket")
    print("4. List All Tickets")
    print("5. Exit")
    choice = input("Choose an option: ")

    if choice == "1":
        name = input("Enter customer name: ")
        movie = "A56"  # 'A' from April + '56' from NPM
        queue.buy_ticket(name, movie)
    elif choice == "2":
        queue.process_ticket()
    elif choice == "3":
        queue.view_next_ticket()
    elif choice == "4":
        queue.list_tickets()
    elif choice == "5":
        break
    else:
        print("Invalid option, try again!")

"""# **Task**

## **Task 1**
"""

class Warehouse:
    def __init__(self, max_capacity):
        self.stack = []
        self.max_capacity = max_capacity

    def push(self, item):
        if len(self.stack) >= self.max_capacity:
            print("Warehouse is full! Cannot add more items.")
        else:
            self.stack.append(item)
            print(f"Added '{item}' to the warehouse.")

    def pop(self):
        if not self.stack:
            print("Warehouse is empty! No items to remove.")
        else:
            removed_item = self.stack.pop()
            print(f"Removed '{removed_item}' from the warehouse.")

    def display(self):
        if not self.stack:
            print("Warehouse is empty.")
        else:
            print("Current items in the warehouse (top to bottom):")
            for item in reversed(self.stack):
                print(item)

def main():
    max_items = 56
    warehouse = Warehouse(max_items)

    while True:
        print("\nOptions: push (add item), pop (remove item), display (show items), capacity (storage capacity), exit (quit)")
        choice = input("Enter command: ").strip().lower()

        if choice == "push":
            item = input("Enter item name: ").strip()
            warehouse.push(item)
        elif choice == "pop":
            warehouse.pop()
        elif choice == "display":
            warehouse.display()
        elif choice == "capacity":
            print(f"Warehouse Storage Capacity: {warehouse.max_capacity} items")
        elif choice == "exit":
            print("Exiting the warehouse system.")
            break
        else:
            print("Invalid command! Please enter a valid option.")

if __name__ == "__main__":
    main()